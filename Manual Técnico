# **MANUAL TÉCNICO - TALLER DE SEGURIDAD IoT**

## **DESCRIPCIÓN GENERAL DEL TALLER**

### **Objetivo Principal:**
Demostrar el ciclo completo de seguridad IoT, desde el reconocimiento hasta la protección, utilizando Python como herramienta principal.

### **Público Objetivo:**
- Estudiantes de ciberseguridad
- Desarrolladores IoT
- Administradores de sistemas
- Entusiastas de la seguridad

### **Requisitos Técnicos:**
- Kali Linux o distribución Linux con Python 3.8+
- 2 dispositivos ESP32 programados con firmware vulnerable
- Router WiFi configurado (Google WiFi recomendado)
- Conocimientos básicos de Python
- Herramientas: hydra, nmap, curl
- Wordlist: rockyou.txt

### **Estructura del Proyecto:**
```
Material para Taller/
├── Codigos Python/          # Scripts Python del taller
│   ├── 1-network_scanner.py
│   ├── 2-real_dictionary_attack.py
│   ├── 3-iot_analyzer.py
│   ├── 4-botnet_demo.py
│   ├── 5-botnet_web_controller.py
│   └── 6-security_tool.py
└── Codigos IoT/             # Firmware ESP32
    ├── ESP32_Simulador_de_Sala/
    └── ESP32_Simulador_de_Entrada/
```

### **Dispositivos ESP32:**
- **ESP32 Simulador de Sala** (IP típica: 192.168.86.114)
  - Credenciales por defecto: admin:123456
  - Funciones: Control de TV, luces, aire acondicionado, lámparas
  
- **ESP32 Simulador de Entrada** (IP típica: 192.168.86.115)
  - Credenciales por defecto: user:12345
  - Funciones: Control de puertas, sistema de alarma, garage

---

## **SCRIPT 1: NETWORK SCANNER**

**Archivo:** `1-network_scanner.py`

### **Descripción:**
Herramienta de descubrimiento y análisis de red que identifica dispositivos IoT y sus servicios expuestos.

### **Objetivos Educativos:**
- Enseñar técnicas de reconnaissance y footprinting de red
- Mostrar identificación de servicios y puertos abiertos
- Demostrar fingerprinting de dispositivos IoT
- Illustrar creación de inventarios de activos de red

### **Funcionalidades Principales:**
- Escaneo paralelo de rangos de IP completos
- Detección de puertos y servicios activos
- Análisis de banners HTTP y respuestas de servicios
- Clasificación automática de tipos de dispositivos
- Identificación específica de objetivos IoT conocidos
- Generación de reportes de inventario detallados

### **Flujo de Ejecución:**
1. Configuración inicial: Define rangos de red a escanear
2. Escaneo paralelo: Examina múltiples IPs simultáneamente
3. Análisis de servicios: Identifica puertos y protocolos activos
4. Fingerprinting: Determina tipos de dispositivos y sistemas
5. Identificación: Localiza objetivos IoT específicos
6. Reporte: Genera inventario completo de la red

### **Impacto en el Taller:**
- Tiempo estimado: 10-15 minutos
- Nivel técnico: Intermedio
- Demuestra: Técnicas de reconocimiento de red
- Enseña: Importancia del inventario de activos

### **Archivos Generados:**
- `scan_results.log` - Reporte JSON con dispositivos descubiertos

---

## **SCRIPT 2: REAL DICTIONARY ATTACK**

**Archivo:** `2-real_dictionary_attack.py`

### **Descripción:**
Ataque de fuerza bruta automatizado contra dispositivos IoT utilizando wordlists para comprometer credenciales débiles.

### **Objetivos Educativos:**
- Demostrar vulnerabilidad de contraseñas débiles en dispositivos IoT
- Enseñar técnicas de fuerza bruta con diccionarios
- Mostrar la importancia de contraseñas robustas
- Illustrar descubrimiento automático de dispositivos vulnerables

### **Funcionalidades Principales:**
- Descubrimiento automático de dispositivos IoT en la red
- Ataques de diccionario usando rockyou.txt
- Prueba de múltiples usuarios comunes (admin, user, root, etc.)
- Progreso en tiempo real con estadísticas
- Guardado automático de credenciales comprometidas
- Generación de archivo JSON con resultados

### **Flujo de Ejecución:**
1. Descubrimiento: Escanea la red local para encontrar dispositivos IoT
2. Carga de wordlist: Lee contraseñas desde rockyou.txt
3. Ataque por dispositivo: Prueba credenciales en cada dispositivo encontrado
4. Validación: Verifica credenciales exitosas mediante autenticación HTTP
5. Almacenamiento: Guarda credenciales comprometidas en JSON
6. Reporte: Muestra resumen de dispositivos comprometidos

### **Impacto en el Taller:**
- Tiempo estimado: 20-30 minutos
- Nivel técnico: Intermedio
- Demuestra: Vulnerabilidad de autenticación débil
- Enseña: Importancia de políticas de contraseñas robustas

### **Archivos Generados:**
- `compromised_devices.json` - Credenciales comprometidas (requerido para scripts siguientes)

---

## **SCRIPT 3: IOT ANALYZER**

**Archivo:** `3-iot_analyzer.py`

### **Descripción:**
Analizador ofensivo que identifica, evalúa y explota vulnerabilidades comunes en dispositivos IoT.

### **Objetivos Educativos:**
- Demostrar explotación de credenciales por defecto
- Mostrar riesgos de endpoints y servicios expuestos
- Enseñar sobre fugas de información en dispositivos IoT
- Illustrar consecuencias de controles remotos comprometidos
- Demostrar técnicas de post-explotación en entornos IoT

### **Funcionalidades Principales:**
- Prueba automatizada de credenciales por defecto
- Escaneo de endpoints web sin autenticación
- Simulación de ataques de fuerza bruta
- Explotación de controles remotos de dispositivos
- Análisis de fugas de información en configuraciones
- Evaluación de configuraciones inseguras
- Generación de reportes de vulnerabilidades detallados

### **Flujo de Ejecución:**
1. Verificación de conectividad: Confirma acceso a dispositivos
2. Prueba de autenticación: Valida credenciales por defecto
3. Escaneo de endpoints: Busca servicios no autenticados
4. Análisis de vulnerabilidades: Identifica configuraciones riesgosas
5. Explotación controlada: Demuestra acceso no autorizado
6. Evaluación de impacto: Documenta consecuencias potenciales
7. Generación de reportes: Crea documentación de hallazgos

### **Impacto en el Taller:**
- Tiempo estimado: 20-25 minutos
- Nivel técnico: Avanzado
- Demuestra: Explotación real de vulnerabilidades IoT
- Enseña: Consecuencias de configuraciones inseguras

### **Archivos Generados:**
- `vulnerability_report.txt` - Reporte detallado de vulnerabilidades encontradas

---

## **SCRIPT 4: BOTNET DEMO**

**Archivo:** `4-botnet_demo.py`

### **Descripción:**
Simulador de botnet que coordina múltiples dispositivos IoT comprometidos para demostrar ataques coordinados.

### **Objetivos Educativos:**
- Mostrar el poder y escalabilidad de las botnets IoT
- Demostrar arquitecturas de comando y control (C&C)
- Enseñar sobre ataques DDoS coordinados
- Illustrar detección y monitoreo de actividad maliciosa
- Demostrar el impacto de dispositivos comprometidos en masa

### **Funcionalidades Principales:**
- Reclutamiento automático de dispositivos comprometidos
- Dashboard de control en tiempo real
- Coordinación de ataques DDoS distribuidos
- Monitoreo de métricas y estadísticas en vivo
- Interfaz interactiva de comando y control
- Simulación de tráfico malicioso coordinado
- Generación de reportes de actividad de botnet

### **Flujo de Ejecución:**
1. Descubrimiento: Identifica dispositivos comprometidos disponibles
2. Reclutamiento: Establece comunicación con bots
3. Configuración: Prepara infraestructura de comando y control
4. Coordinación: Ejecuta ataques simultáneos desde múltiples bots
5. Monitoreo: Supervisa métricas y efectividad en tiempo real
6. Control: Permite operación interactiva de la botnet
7. Reporte: Documenta capacidades y impacto demostrado

### **Impacto en el Taller:**
- Tiempo estimado: 15-20 minutos
- Nivel técnico: Intermedio
- Demuestra: Amenazas avanzadas y coordinadas
- Enseña: Detección y mitigación de botnets

### **Requisitos Previos:**
- Archivo `compromised_devices.json` generado por Script 2

---

## **SCRIPT 5: BOTNET WEB CONTROLLER**

**Archivo:** `5-botnet_web_controller.py`

### **Descripción:**
Panel web interactivo para monitorear y controlar dispositivos IoT comprometidos en tiempo real.

### **Objetivos Educativos:**
- Demostrar interfaces de comando y control (C&C) modernas
- Mostrar visualización de datos en tiempo real
- Enseñar sobre monitoreo de actividad maliciosa
- Illustrar dashboards de gestión de botnets

### **Funcionalidades Principales:**
- Interfaz web moderna y responsive
- Monitoreo en tiempo real de estado de bots
- Estadísticas visuales de actividad
- Control remoto de dispositivos comprometidos
- Actualización automática de estado
- Visualización de métricas de ataque

### **Flujo de Ejecución:**
1. Inicialización: Carga dispositivos desde compromised_devices.json
2. Servidor web: Inicia servidor Flask en puerto 5000
3. Dashboard: Muestra estado de todos los bots
4. Monitoreo: Actualiza estado en tiempo real
5. Control: Permite enviar comandos a dispositivos
6. Estadísticas: Muestra métricas y actividad

### **Uso:**
```bash
python3 5-botnet_web_controller.py
# Luego abrir http://localhost:5000 en el navegador
```

### **Impacto en el Taller:**
- Tiempo estimado: 10-15 minutos
- Nivel técnico: Intermedio
- Demuestra: Interfaces modernas de C&C
- Enseña: Visualización de amenazas en tiempo real

### **Requisitos Previos:**
- Archivo `compromised_devices.json` generado por Script 2
- Biblioteca Flask instalada (`pip3 install flask`)

---

## **SCRIPT 6: SECURITY TOOL**

**Archivo:** `6-security_tool.py`

### **Descripción:**
Conjunto de herramientas defensivas para proteger infraestructuras IoT mediante monitoreo y hardening.

### **Objetivos Educativos:**
- Enseñar medidas defensivas prácticas para entornos IoT
- Mostrar técnicas de monitoreo continuo de red
- Demostrar detección de dispositivos no autorizados
- Illustrar evaluación de configuraciones seguras
- Proporcionar recomendaciones de hardening específicas

### **Funcionalidades Principales:**
- Descubrimiento automático y catalogación de dispositivos
- Análisis continuo de vulnerabilidades
- Monitoreo en tiempo real de actividad de red
- Detección de cambios y anomalías en la infraestructura
- Evaluación de configuraciones de seguridad
- Generación de recomendaciones de hardening personalizadas
- Creación de reportes de estado de seguridad

### **Flujo de Ejecución:**
1. Inventario inicial: Escanea y cataloga todos los dispositivos de red
2. Evaluación de base: Establece línea base de seguridad
3. Monitoreo continuo: Vigila actividad y cambios en la red
4. Detección de anomalías: Identifica comportamientos sospechosos
5. Análisis de vulnerabilidades: Evalúa configuraciones riesgosas
6. Generación de recomendaciones: Crea guías de hardening específicas
7. Reporte de estado: Documenta postura de seguridad actual

### **Impacto en el Taller:**
- Tiempo estimado: 10-15 minutos
- Nivel técnico: Intermedio
- Demuestra: Herramientas defensivas prácticas
- Enseña: Monitoreo proactivo y hardening

---

## **FLUJO PEDAGÓGICO COMPLETO**

### **Fase 1: Concientización (15 minutos)**
- Introducción a riesgos IoT
- Caso de estudio: Botnet Mirai
- Contexto del laboratorio práctico

### **Fase 2: Ofensiva Controlada (75 minutos)**
- Script 1: Reconocimiento de red (10-15 min)
- Script 2: Ataque de fuerza bruta (20-30 min)
- Script 3: Análisis y explotación (20-25 min)
- Script 4: Demostración de botnet (15-20 min)
- Script 5: Panel web de control (10-15 min)

### **Fase 3: Defensa Práctica (10-15 minutos)**
- Script 6: Herramientas defensivas (10-15 min)

### **Resultados de Aprendizaje:**
- Comprensión de vectores de ataque IoT
- Habilidades prácticas de evaluación de seguridad
- Conocimiento de herramientas defensivas
- Conciencia de mejores prácticas de seguridad

---

## **CONSIDERACIONES DE SEGURIDAD**

### **Entorno Controlado:**
Todos los scripts están diseñados para ejecutarse exclusivamente en entornos de laboratorio controlados con dispositivos de propiedad del instructor.

### **Propósito Educativo:**
Las herramientas tienen fines exclusivamente educativos y de concientización sobre seguridad IoT.

### **Cumplimiento Legal:**
El taller debe realizarse en redes aisladas con dispositivos propiedad de la organización educativa.

### **Ética Profesional:**
Se enfatiza la importancia del consentimiento y la autorización en todas las actividades de seguridad.

---

## **INSTALACIÓN Y CONFIGURACIÓN**

### **Preparación del Entorno:**

1. **Instalar herramientas en Kali Linux:**
```bash
sudo apt update
sudo apt install -y hydra nmap curl python3 python3-pip
```

2. **Verificar wordlist rockyou.txt:**
```bash
ls -lh /usr/share/wordlists/rockyou.txt
# Si no existe, descomprimir:
sudo gunzip /usr/share/wordlists/rockyou.txt.gz
```

3. **Instalar bibliotecas Python:**
```bash
pip3 install requests flask scapy
```

4. **Configurar dispositivos ESP32:**
   - Abrir archivos `.ino` en Arduino IDE
   - Configurar credenciales WiFi
   - Subir firmware a cada ESP32
   - Anotar IPs asignadas

5. **Verificar conectividad:**
```bash
ping -c 4 192.168.86.114
ping -c 4 192.168.86.115
curl -I http://192.168.86.114/
curl -I http://192.168.86.115/
```

### **Orden de Ejecución de Scripts:**

Los scripts deben ejecutarse en el siguiente orden para que funcionen correctamente:

1. `1-network_scanner.py` - Descubre dispositivos
2. `2-real_dictionary_attack.py` - Compromete credenciales (genera `compromised_devices.json`)
3. `3-iot_analyzer.py` - Analiza vulnerabilidades
4. `4-botnet_demo.py` - Demuestra botnet (requiere `compromised_devices.json`)
5. `5-botnet_web_controller.py` - Panel web (requiere `compromised_devices.json`)
6. `6-security_tool.py` - Herramientas defensivas

### **Archivos Generados por los Scripts:**

- `scan_results.log` - Resultados del escaneo de red (Script 1)
- `compromised_devices.json` - Credenciales comprometidas (Script 2, requerido por Scripts 4 y 5)
- `vulnerability_report.txt` - Reporte de vulnerabilidades (Script 3)
- `security_report.txt` - Reporte de seguridad (Script 6)

---

## **DETALLES TÉCNICOS ADICIONALES**

### **Protocolos y Tecnologías Utilizadas:**

- **HTTP Basic Authentication:** Autenticación utilizada por los dispositivos ESP32
- **REST API:** Endpoints HTTP para control de dispositivos
- **Flask:** Framework web para el panel de control
- **Concurrent Processing:** Escaneo paralelo con ThreadPoolExecutor
- **JSON:** Formato de almacenamiento de datos

### **Rangos de Red:**

- Los scripts detectan automáticamente la red local
- Por defecto asumen red /24 (254 hosts)
- Pueden configurarse rangos específicos si es necesario

### **Puertos Escaneados:**

- Puerto 80 (HTTP) - Principal
- Puerto 443 (HTTPS) - Si está disponible
- Puerto 8080 (HTTP alternativo) - Si está disponible

### **Credenciales por Defecto Probadas:**

- admin:admin, admin:123456, admin:password
- user:user, user:12345, user:123456
- root:root, root:123456
- guest:guest

### **Endpoints Comunes Escaneados:**

- `/`, `/admin`, `/config`, `/settings`
- `/api`, `/control`, `/status`, `/info`
- `/lights`, `/tv`, `/ac`, `/door`, `/alarm`

---

**Este manual técnico proporciona la base completa para entender y ejecutar el taller de seguridad IoT de manera educativa y responsable.**